{
    "title": "Group72_Opening_ZxShell",
    "text": "Threat Spotlight: Group 72, Opening the ZxShellThis post was authored by Andrea Allievi, Douglas Goddard, Shaun Hurley, and Alain Zidouemba.Recently, there was a blog post on the takedown of a botnet used by threat actor group known as Group 72 and theirinvolvement in Operation SMN.  This group is sophisticated, well funded, and exclusively targets high profile organizationswith high value intellectual property in the manufacturing, industrial, aerospace, defense, and media sector. The primaryattack vectors are watering-hole, spear phishing, and other web-based attacks.Frequently, a remote administration tool (RAT) is used to maintain persistence within a victim’s organization. These toolsare used to further compromise the organization by attacking other hosts inside the targets network.ZxShell (aka Sensocode) is a Remote Administration Tool (RAT) used by Group 72 to conduct cyber-espionage operations.Once the RAT is installed on the host it will be used to administer the client, exfiltrate data, or leverage the client as a pivot toattack an organization’s internal infrastructure.  Here is a short list of the types of tools included with ZxShell:Keylogger (used to capture passwords and other interesting data)Command line shell for remote administrationRemote desktopVarious network attack tools used to fingerprint and compromise other hosts on the networkLocal user account creation toolsFor a complete list of tools please see the MainConnectionIo section.The following paper is a technical analysis on the functionality of ZxShell. The analysts involved were able to identifycommand and control (C2) servers, dropper and installation methods, means of persistence, and identify the attack tools thatare core to the RAT’s purpose. In addition, the researchers used their analysis to provide detection coverage for Snort,Fireamp, and ClamAV.Table of Contents1. Background2. Distribution and Delivery3. Analysis of the main ZxShell moduleDllMainInstallServiceMainShellMainShellMainThreadGetIpListAndConnectMainConnectionIoUninstallZxFunction001ZxFunction0024. Command and Control server5. Malware Package6. Version Information7. Extracted URL Analysis8. Conclusion9. Protecting Users From These Threats10. Appendix A: Snort rules11. Appendix B: ClamAV signatures12. Appendix C: List of Memory Offsets for Some ZxShell Functions13. Appendix D: Other CollateralBackgroundZxShell has been around since 2004. There are a lot of versions available in the underground market. We have analyzed themost common version of ZxShell, version 3.10. There are newer versions, up to version 3.39 as of October 2014.Distribution and DeliveryAn individual who goes by the name LZX in some online forums is believed to be the original author of ZxShell. Since ZxShellhas been around since at least 2004, numerous people have purchased or obtained the tools necessary to set up ZxShellcommand and control servers (C&C) and generate the malware that is placed on the victim’s network. ZxShell has beenobserved to be distributed through phishing attacks, dropped by exploits that leverage vulnerabilities such as CVE-2011-2462, CVE-2013-3163, and CVE-2014-0322.Analysis of the Main ZxShell ModuleTo illustrate the functionality of main ZxShell module, Let’s take a look at the following sample:MD5: e3878d541d17b156b7ca447eeb49d96aSHA256: 1eda7e556181e46ba6e36f1a6bfe18ff5566f9d5e51c53b41d08f9459342e26cIt exports the following functions, which are examined in greater detail below:DllMainInstallUnInstallServiceMainShellMainShellMainThreadzxFunction001zxFunction002DllMainDllMain performs the initialization of ZxShell. It allocates a buffer of 0x2800 bytes and copies the code for theZxGetLibAndProcAddr function. To copy memory, the memcpy function is invoked. It is not directly used from msvcrt.dll butis instead copied to another memory chunk before being called. Finally, the trojan Import Address Table (IAT) is resolvedand the file path of the process that hosts the dll is resolved and saved in a global variable.InstallZxShell.dll is injected in a shared SVCHOST process. The Svchost group registry keyHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost is opened and the netsvc group value data is queriedto generate a name for the service.Before the malware can be installed a unique name must to be generated for the service. The malware accomplishes thisthrough querying the netsvc group value data located in the svchost group registry key which isHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost.At startup, Svchost.exe checks the services part of the registry and constructs a list of services to load. Each Svchost sessioncan contain multiple shared services that are organized in groups. Therefore, separate services can run, depending on howand where Svchost.exe is started.\nImage 1. Svchost Groups registry keySvchost.exe groups are identified in the above registry key. Each value under this key represents a separate Svchost groupand appears as a separate instance when you are viewing active processes. Each value is a REG_MULTI_SZ value andcontains the services that run under that Svchost group. Each Svchost group can contain one or more service names that areextracted from the following registry key, whose Parameters key contains a ServiceDLL value:HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\ServiceOn a Windows machine, the netsvc group contains names of both existing and non-existing services. ZxShell exploits this factby cycling between each of the names, verifying the existence of the real service. The service’s existence is verified with theServiceExists function, which attempts to open the relative registry sub-key in HKLM\\SYSTEM\\CurrentControlSet\\Services.The first service name that is not installed on the system becomes the ZxShell service name.A new service is then created using the service parser function ProcessScCommand. ZxShell implemented its own version ofthe Windows SC command. There are minor differences between the ZxShell implementation of this command and theoriginal Windows one, but they are irrelevant for the purpose of the analysis The command used to install the service is:sc create <service name> <service name> “%SystemRoot%\\System32\\svchost.exe -k netsvcs”where <service name> is the chosen infected service name.Image 2. “SC” command used to create the target service,and parsed by “ProcessScCommand” routineThe installed service registry key is opened and the 2 values under its Parameter subkey are created. These 2 values,ServiceDll and ServiceDllUnloadOnStop are needed for services that run in a shared process.Before the service is started ChangeServiceConfig is called to modify the service type to shared and interactive. If the servicefails to start then a random service name formatted as netsvc_xxxxxxxx, where xxxxxxxx represent an 8-digit random hexvalue, is added to the netsvc group and the entire function is repeated.ServiceMainThis function is the entry point of the service. It registers the service using the RegisterServiceCtrlHandler Windows APIfunction. The ZxShell service handler routine is only a stub: it responds to each service request code, doing nothing, andfinally exits. It sets the service status to RUNNING and finally calls the ShellMain function of ZxShell.ShellMainThe ShellMain function is a stub that relocates the DLL to another buffer and spawns a thread that starts fromShellMainThreadInt at offset +0xC0CD. The ShellMainThreadInt function gets the HeapDestroy Windows API address andreplaces the first 3 bytes with the RET 4 opcode. Subsequently, it calls the FreeLibrary function to free its own DLL bufferlocated at its original address. Because of this, the allocated heaps will not be freed. It re-copies the DLL from the new bufferto the original one using the memcpy function. Finally, it spawns the main thread that starts at the original location ofShellMainThread procedure, and terminates. At this point, the ZxShell library is no longer linked in the module list of thehost process. This is important because if any system tool tries to open the host process it will never display the ZxShell DLL.ShellMainThreadThis thread implements the main code, responsible for the entire botnet DLL. First, it checks if the DLL is executed as aservice. If so, it spawns the service watchdog thread. The watchdog thread checks the registry path of the ZxShell serviceevery 2 seconds, to verify that it hasn’t been modified. If a user or an application modifies the ZxShell service registry key, thecode restores the original infected service key and values.Image 3. The watchdog thread of ZxShell serviceThe buffer containing the ZxShell Dll in the new location is freed using the VirtualFree API function. A handle to the DLL fileis taken in order to make its deletion more difficult. The ZxShell mutex is created named @_ZXSHELL_@.ZxShell plugins are parsed and loaded with the AnalyseAndLoadPlugins function. The plugin registry keyHKLM\\SYSTEM\\CurrentControlSet\\Control\\zxplug is opened and each value is queried. The registry value contains theplugin file name. The target file is loaded using the LoadLibrary API function, and the address of the exported functionzxMain is obtained with GetProcAddress.If the target filename is incorrect or invalid the plugin file is deleted and the registry value is erased. That is performed by thefunction DeleteAndLogPlugin. Otherwise, the plugin is added to an internal list. Here is the data structure used to keep trackof the plugins:typedef struct _ZX_PLUGINS_STRUCT {    LPSTR lpStrRegKey;        // + 0x00 - ZxShell Plugins registry key string // (like 'SYSTEM\\CurrentControlSet\\Control\\zxplug')    DWORD dwUnknown2;        // + 0x04 - Unknown DWORD value    LPVOID lp138hBuff;        // + 0x08 - Plugins list    DWORD dwZero;            // + 0x0C - Always zero    HANDLE hReg;            // + 0x10 - Handle to plugin registry key} ZX_PLUGINS_STRUCT, *PZX_PLUGINS_STRUCT;The thread KeyloggerThread is spawned and is responsible for doing keylogging on the target workstation. We will take alook at the keylogger later on. Finally the main network communication function GetIpListAndConnect is called.GetIpListAndConnectThis function is at the core of the RAT’s network communication. It starts by initializing a random number generator andreading 100 bytes inside the ZxShell Dll at a hardcoded location. These bytes are XOR encrypted with the byte-key 0x85 andcontains a list of remote hosts where to connect. The data is decrypted, the remote host list is parsed and verified using theBuildTargetIpListStruct function. There are 3 types of lists recognized by ZxShell: plain ip addresses, HTTP and FTPaddresses.If the list does not contain any item, or if the verification has failed, the ZxShell sample tries to connect to a hardcoded host with the goal of retrieving a new updated list.Otherwise, ZxShell tries to connect to the first item of the list. If ZxShell successfully connects to the remote host, thefunction DoHandshake is called. This function implements the initial handshake which consists of exchanging 16 bytes,0x00001985 and 0x00000425,  with the server. The function GetLocalPcDescrStr is used to compose a large string thatcontains system information of the target workstation. That information is the following:local hostnameorganizationowneroperating system detailsCPU speedtotal physical memoryThe string is sent to the remote host and the response is checked to see if the first byte of the response is 0xF4, an arbitrarybyte. If it is, the botnet connection I/O procedure is called through the MainConnectionIo function.\nImage 4. The GetLocalPcDescrStr and DoHandshake functions called beforestarting the command processingOtherwise, the ZxShell code closes the socket used and sleeps for 30 seconds. It will then retry the connection with the nextremote host, if there is one.It is noteworthy that this function includes the code to set the ZxShell node as a server: if one of the hardcoded boolean valueis set to 1, a listening socket is created. The code waits for an incoming connection. When the connection is established a newthread is spawned that starts with the MainConnectionIo function.MainConnectionIoThe MainConnectionIo function checks if the Windows Firewall is enabled, sets the Tcp Keep Alive value and Non-blockingmode connection options and receives data from the remote host through the ReceiveCommandData function. If thecommunication fails, ZxShell disables the firewall by modifying the registry key:HKLM\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfileThen the connection is retried. The received command is then processed by the ZxShell function with the ProcessCommandfunction.The command processing function starts by substituting the main module name and path in the hosting process PEB, withthe one of the default internet browser. The path of the main browser of the workstation is obtained by reading the registryvalue:HKLM\\SOFTWARE\\Classes\\HTTP\\shell\\open\\command\nImage 5. Our test workstation use Windows Internet Explorer as default browserThis trick renders identification by firewall more cumbersome. A host firewall  will recognize the outgoing connection asoriginated by the browser instead of the ZxShell service host process. The browser process always performs outgoingconnections and the firewall shouldn’t block them.The command processing is straightforward. Here is the list of common commands:COMMANDMEANINGHelp / ?Get helpExit / QuitExit and shut down the botnet clientSysInfoGet target System informationSYNFloodPerform a SYN attack on a hostPsProcess service Unix command implementationCleanEventClear System Event logFindPassFind login account passwordFileTimeGet time information about a fileFindDialPassList all the dial-up accounts and passwordsUserAccount Management SystemTransFileTransfer file in or from remote hostExecuteRun a program in the remote hostSCService control command, implemented as the Windows oneCAClone user accountRunAsCreate new process as another User or Process context.TermSvcTerminal service configuration (working on Win Xp/2003)GetCMDRemote ShellShutdownLogout, shutdown or restart the target systemZXARPSSpoofing, redirection, packet captureZXNCRun ZXNC v1.1 -- a simple telnet clientZXHttpProxyRun a HTTP proxy server on the workstationZXSockProxyRun a Sock 4 & 5 Proxy serverZXHttpServerRun a custom HTTP serverPortScanRun TCP Port MultiScanner v1.0KeyLogCapture or record the remote computer’s keystrokes. The implementation is a userland keylogger that polls thekeymap with each keystroke.LoadDllLoad a DLL into the specified processEndTerminate ZxShell DLLUninstallUninstall and terminate ZxShell bot DLLShareShellShare a shell to otherCloseFWSwitch off Windows FirewallFileMGFile ManagerwinvncRemote DesktoprPortMapPort ForwardingcapsrvVideo Device SpyingzxplugAdd and load a ZxShell custom pluginThis set of functionality allows the operator complete control of a system. Being able to transfer and execute files on theinfected system means the attacker can run any code they please. Further, the keylogging and remote desktop functionalityallows the operator to spy on the infected machine, observing all keystrokes and viewing all user actions.UninstallUnloads ZxShell and deletes all of the active components. This simply deletes the ZxShell service key from the Windowsregistry (using SHDeleteKey Api) and all of the subkeys. Finally, it marks ZxShell main Dll for deletion with the MoveFileExWindows API.ZxFunction001This function is the supporting functionality for WinVNC. To allow the VNC session to connect, the current network socketWSAProtcol_Info structure is written to a named pipe prior to calling zxFunction001. Once the named pipe has been created,CreateProcessAsUserA is called with the following as the CommandLine parameter :<systemroot>\\\\rundll32.exe <zxshell dll name>,zxFunction001 <name of NamedPipe>zxFunction001 modifies the current process memory, uses data contained in the named pipe to create a socket, and thenexecutes the code that sends the remote desktop session to the server controller.ZxFunction002This function will either bind the calling process to a port or has the calling process connect to a remote host. The function iscalled in the following manner:<systemroot>\\\\rundll32.exe <zxshell dll name>,zxFunction002 <name of NamedPipe>The functionality (connect or bind) depends on the data contained within the named pipe. Unlike zxFunction001, this is notused by  any of the RAT commands in the zxshell.dll.Kernel Device Driver LoveUSDApart from user-mode ZxShell droppers mentioned earlier, there is a file (SHA256:1e200d0d3de360d9c32e30d4c98f07e100f6260a86a817943a8fb06995c15335) that installs a kernel device driver calledloveusd.sys. The architecture of this dropper is different from the others: it starts extracting the main driver from itself. Itadds the SeLoadDriver privilege to its access token and proceeds to install the driver as a fake disk filter driver. ZxShell opensthe registry key that describes the disk class drivers:SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E967-E325-11CE-BFC1-08002BE10318}It then adds the “Loveusd.sys” extracted driver name to the upper filter list. In our analysed sample the “Loveusd.sys” driveris installed with the name “USBHPMS”. Finally the driver is started using the ZwLoadDriver native API.The ZxShell driver starts by acquiring some kernel information and then hooking “ObReferenceObjectByHandle” API. Finallyit spawns 2 system threads.The first thread is the “communication” thread. ZxShell employs a strange method for communication: it hooks theNtWriteFile API and recognizes 5 different special handle values as commands:0x111111111 -- Hide “Loveusd” driver from the system kernel driver list0x22222222 -- Securely delete an in-use or no-access target file-name0x44444444 -- Unhook the ZwWriteFile API and hook KiFastCallEntry0x55555555 -- Remove the ZxShell Image Load Notify routine0x88888888 -- Set a special value called “type” in Windows registry keyHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DriverMainThe second Loveusd system thread does a lot of things. Its principal duties are to create the ZxShell main DLL in“c:\\Windows\\System32\\commhlp32.dll” and to install the Kernel “Load Image Notify routine”. The code then tries to killeach process and service that belongs to the following list of AV products:Symantec FirewallNortonESETMcAfeeAvastAviraSophosMalwarebytesNext, the ZxShell Load-Image Notify function prevents the AV processes from restarting.The installation procedure continues in the user-mode dropper. The ZxShell service is installed as usual, and the in-executiondropper is deleted permanently using the special handle value 0x22222222 for the WriteFile API call. This handle value isinvalid: all the windows kernel handle values are by design a multiple of 4. The ZxShell hook code knows that and interceptit.ObReferenceObjectByHandle is a Kernel routine designed to validate a target object and return the pointer to its object body(and even its handle information), starting from the object handle (even the user-mode one). The hook installed by ZxShellimplements one of its filtering routine. It filters each attempt to open the ZxShell protected driver or the main DLL, returninga reference to the “netstat.exe” file. The protection is enabled to all processes except for ones in the following list:Svchost.exe, Lsass.exe, Winlogon.exe, Services.exe, Csrss.exe, ctfmon.exe, Rundll32.exe, mpnotify.exe, update.exe.If the type of the object that the system is trying to validate is a process, the hook code rewrites again the configuration dataof the ZxShell service in the windows registry.\nImage 6. Our test Windows XP workstation trying to open the sys file of ZxShell LOVEUSD driverThe last type of Kernel modification that ZxShell rootkit performs is the system call dispatcher (KiFastCallEntry) hook. Inthis manner, ZxShell is able to completely hide itself, intercepting the following Kernel API calls: ZwAllocateVirtualMemory,ZwOpenEvent, ZwQueryDirectoryFile, ZwWriteFile, ZwEnumerateKey, and ZwDeviceIoControlFile.Command and Control ServerSample (SHA256: 1eda7e556181e46ba6e36f1a6bfe18ff5566f9d5e51c53b41d08f9459342e26c) is configured to act as a server.The symbol “g_bCreateListenSck” is set to 1. This means that, as seen above, the ZxShell Dll is started in listening mode. Itconnects to the first remote C&C that tries to contact it and succeeds in the handshake. The encrypted IP address is“127.0.0.2” (used as loopback) and no connection is made on that IP address (due to the listening variable set to 1).Malware PackageWe used the ZxShell package for version 3.10 (SHA256:1622460afbc8a255141256cb77af61c670ec21291df8fe0989c37852b59422b4).The convenient thing about this is that the CNCpanel worked with any version, 3.10 and above. The buttons are all in Chinese, with the help of Google Translate and keendetective skills (read: button clicking), we’ve deciphered the functionality.When you start the controller, you need to set the port you want to listen on and if you’ve set a password, add it here.\nOnce an infected machine connects, you see its information displayed in a selection box at the top. There are some built infunctions on the side for the more common features. These include remote desktop, webcam spying, remote shell, and filemanagement. You can also select a host and type help for a full list of commands.I have the same machine infected with two different version of ZxShell. Sending the help command for each, you can see theextra features added between version 3.1 and 3.2.\nKeylogging, ZXARPS (IP and URL spoofing), and SYNFlood are some of the interesting features added to version 3.2.Version InformationWe wrote a script to extract version info from the binaries we have.3.100 : 9143.200 : 1523.210 : 1183.220 : 143.390 : 3In versions 3.1 -- 3.21, the configuration info is xor encoded with 0x85. This configuration info can be changed with a toolincluded in the ZxShell package.\nIn versions 3.22 and 3.39 the routine changes. The new xor encoding byte is 0x5B. The data is stored in the last 0x100 bytesof the file. The first 8 bytes of data are static. Then there is the dll install name, the domain, and the port.Extracted URL AnalysisKnowing the obfuscation routines for this data we wrote a script to extract the URLs / IPs and ports stored.The most common ports used are, 80, 1985, 1986, and 443. 1985 is the default port for the malware, 1986 is the lazy variationof that port. Port 80 and 443 are the default ports for HTTP and HTTPS traffic. The next most common is port 53. This isused in some of the newer 3.22 and 3.39 samples. After that, the count for each port starts declining sharply. The choices areinteresting though, many correspond to what looks like the birth year of the controller (ie. years in the late 1980s and early1990s), and others seem to match what year the malware was launched in (ie. in the 2000s, relatively close to the currentyear).Since this malware dates back to around 2004, there are many samples containing CNC URLs from the 3322.org page. Thispage used to offer no-ip type hosting and was widely used by malware authors. So much so that Microsoft did a takedown in2012. A similar service, vicp.net, is also seen in many of the domains.In the malware, if a domain is configured, it will retrieve domain.tld/myip.txt. This file contains a list of IP addresses for theinfected machine to connect back to. Otherwise, if an IP address is configured, it will connect directly to that IP address.Cloning the ZxShell ServerWe have written a simple C++ ZxShell Server that implements the communication and the handshake for the version 3.10and 3.20 of the ZxShell DLL. The implementation is quite simple: After the handshake, 2 threads that deal with data transferare spawned. Here we have some screenshots that show the Server and the ZxShell Keylogger in action:\nOur server has accepted a connection from a remote host\nThe ZxShell keylogger has captured 2 user passwords(gmail.com and amazon.com)The last image shows a very interesting feature of the ZxShell keylogger: once installed and activated, the keylogger is able tocatch each password that the user inserts in the login box of each website (like Google, Amazon and so on…). This makes thekeylogger a perfect weapons for the attackers. They will be able to steal and resell in the underground market the sensitivedata of each victim.ConclusionAdvanced persistent threats will remain a problem for companies and organizations of all sizes, especially those with highfinancial or intellectual property value.  Group 72’s involvement in Operation SMN is another example of what sort ofdamage that can be done if organizations are not diligent in their efforts to secure their networks.  ZxShell is one sampleamongst several tools that Group 72 used within their campaign.ZxShell is a sophisticated tool employed by Group 72 that contains all kinds of functionality.  Its detection and removal canbe difficult due to the various techniques used to conceal its presence, such as disabling the host anti-virus, masking itsinstallation on a system with a valid service name, and by masking outbound traffic as originating from a web browser. While other techniques are also utilized to conceal and inhibit its removal, ZxShell’s primary functionality is to act as aRemote Administration Tool (RAT), allowing the threat actor to have continuous backdoor access on to the compromisedmachine.As our analysis demonstrates, ZxShell is an effective tool that can be ultimately used to steal user credentials and other highlyvaluable information. The threat posed by ZxShell to organizations is one that cannot be ignored.  Organizations with highfinancial or intellectual property value should take the time to ensure their security requirements are met and thatemployee’s are educated about the security threats their organizations face.For additional information, please see our blog post.Protecting Users from These ThreatsAdvanced Malware Protection (AMP) is ideally suited to detect the sophisticated malwareused by this threat actor.CWS or WSA web scanning prevents access to malicious websites, including watering holeattacks, and detects malware used in these attacks.The Network Security protection of IPS and NGFW have up-to-date signatures to detectmalicious network activity by threat actors.ESA can block spear phishing emails sent by threat actors as part of their campaign.Appendix A: Snort RulesInitial connection from the infected computer’s perspective -- after it connects to the controller -RECV:  85190000250400000000404000000000SEND:  86190000040100006666464000000000RECV:  4edf9340780100000000000000000000SEND:  00000000000000000000000000000000The rules are on the first 8 bytes of the first two packets. They are hard coded in the binaries. The rest of the bytes arevariable (for example, 66664640 is a floating point version number of ZxShell).Snort rules:sid:32180sid:32181These rules have been released in our community ruleset and can be downloaded and used directly, or via pulledpork fromSnort.orgAppendix B: ClamAV SignaturesWin.Trojan.ZxShell-11Win.Trojan.ZxShell-12Win.Trojan.ZxShell-13Win.Trojan.ZxShell-14Win.Trojan.ZxShell-15Win.Trojan.ZxShell-16Win.Trojan.ZxShell-17Win.Trojan.ZxShell-18Win.Trojan.ZxShell-19Win.Trojan.ZxShell-20Win.Trojan.ZxShell-21Win.Trojan.ZxShell-22Win.Trojan.ZxShell-23Win.Trojan.ZxShell-24Win.Trojan.ZxShell-25Win.Trojan.ZxShell-26These signatures are available within the ClamAV database.  Please run freshclam to ensure you stay updated with the latestcoverage.Appendix C: List of Memory Offsets for Some ZxShell FunctionsHere’s a list for some ZxShell functions for sample SHA256:1eda7e556181e46ba6e36f1a6bfe18ff5566f9d5e51c53b41d08f9459342e26c:FUNCTION NAMEBRIEF DESCRIPTIONOFFSETZxGetLibAndProcAddrZxShell GetProcAddress implementation0x12CDACopyMemoryFromNewMsvcrtZxShell memory copy routine0x12C4CServiceExistsGet if a service is installed in the system or not0x0A7C7ProcessScCommandZxShell “SC” command implementation0x0E3EFAnalyseAndLoadPluginsParse the installed plugin list and load each one of them0x0127B7DeleteAndLogPluginDelete a corrupted plugin and log the problem0x012597KeyloggerThreadZxShell keylogger implementation0x0D591GetIpListAndConnectAnalyse the IP list inside the ZxShell PE and tries to connect0x011496BuildTargetIpListStructBuild remote server Ip list structure0x11419DoHandshakePerform initial connection handshake0xB8E8GetLocalPcDescrStrBuild a string containing the target workstation data0x0B627MainConnectionIoZxShell main connection I/O routine0x1126CReceiveCommandDataReceive each byte from the socket until a newline char0x016DFProcessCommandMain ZxShell command processing routine0x10C2BAppendix D: Other CollateralHere is a non-exhaustive list of ZxShell samples that were analyzed for this report.Here is a list of Domains organized by port.Tags: APT, Group 72, malware, Operation SMN, security, SMN, Talos, threats"
}